name: Issue automation: ready-for-release + release closing (bugs & features)

on:
  issues:
    types: [labeled]
  release:
    types: [published]
  workflow_dispatch:

permissions:
  issues: write
  contents: read

jobs:
  automate:
    runs-on: ubuntu-latest
    steps:
      - name: Comment / label / close
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            // ---- Labels in your repo (keep names EXACT) ----
            const LABELS = {
              bugWaiting: 'Bug fixed - created - waiting for release',
              bugReleased: 'Bug fixed - released',

              featureWaiting: 'New feature - created - waiting for release',
              featureAddedReleased: 'Feature added - released',
              featurePlanned: 'Feature will be added',

              // Legacy labels you said existed before (safe to remove if present)
              legacyBugFixed: 'Bug fixed',
              legacyFeatureAdded: 'Feature added',
            };

            // ---- Comment markers (so we can update instead of spamming) ----
            const MARKERS = {
              bugWaiting: '<!-- status:bug-waiting-release -->',
              featureWaiting: '<!-- status:feature-waiting-release -->',
              bugReleased: '<!-- status:bug-released -->',
              featureReleased: '<!-- status:feature-released -->',
            };

            function waitingBody(type) {
              if (type === 'bug') {
                return `${MARKERS.bugWaiting}
            âœ… Denne bug er markeret som **fikset** og bliver udgivet i **nÃ¦ste release**.

            NÃ¥r releasen bliver udgivet, bliver dette issue automatisk opdateret og lukket.

            Hvis problemet stadig findes efter release, sÃ¥ skriv en kommentar der indeholder **reopen** (sÃ¥ Ã¥bner den automatisk igen).`;
              }

              if (type === 'feature') {
                return `${MARKERS.featureWaiting}
            âœ… Denne feature er markeret som **klar** og bliver udgivet i **nÃ¦ste release**.

            NÃ¥r releasen bliver udgivet, bliver dette issue automatisk opdateret og lukket.

            Hvis noget stadig mangler efter release, sÃ¥ skriv en kommentar der indeholder **reopen** (sÃ¥ Ã¥bner den automatisk igen).`;
              }

              throw new Error('Unknown waiting type: ' + type);
            }

            function releasedBody(type, version, url) {
              if (type === 'bug') {
                return `${MARKERS.bugReleased}
            âœ… **Bug fix udgivet** i **${version}**
            ðŸ”— ${url}

            Hvis problemet stadig findes, sÃ¥ skriv en kommentar der indeholder **reopen**.`;
              }

              if (type === 'feature') {
                return `${MARKERS.featureReleased}
            âœ… **Feature udgivet** i **${version}**
            ðŸ”— ${url}

            Hvis noget stadig mangler, sÃ¥ skriv en kommentar der indeholder **reopen**.`;
              }

              throw new Error('Unknown released type: ' + type);
            }

            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, name, color, description });
                  core.info(`Created label: ${name}`);
                } else {
                  throw e;
                }
              }
            }

            async function listAllComments(issue_number) {
              return await github.paginate(
                github.rest.issues.listComments,
                { owner, repo, issue_number, per_page: 100 }
              );
            }

            async function upsertComment(issue_number, marker, body) {
              const comments = await listAllComments(issue_number);
              const existing = comments.find(c => (c.body || '').includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
                return;
              }

              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

            async function safeRemoveLabel(issue_number, name) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
              } catch (e) {
                if (e.status !== 404) throw e;
              }
            }

            async function getReleaseInfo() {
              // release event -> use payload
              if (context.eventName === 'release') {
                const rel = context.payload.release;
                const version = rel.tag_name || rel.name || 'unknown';
                const url = rel.html_url;
                return { version, url };
              }

              // workflow_dispatch -> use latest non-draft, non-prerelease
              const releases = await github.rest.repos.listReleases({ owner, repo, per_page: 50 });
              const latest = releases.data.find(r => !r.draft && !r.prerelease);
              if (!latest) return null;

              return {
                version: latest.tag_name || latest.name || 'unknown',
                url: latest.html_url,
              };
            }

            async function issuesWithLabelOpen(labelName) {
              const issues = await github.paginate(
                github.rest.issues.listForRepo,
                { owner, repo, state: 'open', labels: labelName, per_page: 100 }
              );
              return issues.filter(i => !i.pull_request);
            }

            async function closeAsReleased(issue, type, version, url) {
              const issue_number = issue.number;

              // 1) Comment
              if (type === 'bug') {
                await upsertComment(issue_number, MARKERS.bugReleased, releasedBody('bug', version, url));
              } else {
                await upsertComment(issue_number, MARKERS.featureReleased, releasedBody('feature', version, url));
              }

              // 2) Labels
              if (type === 'bug') {
                await safeRemoveLabel(issue_number, LABELS.bugWaiting);
                await safeRemoveLabel(issue_number, LABELS.legacyBugFixed); // legacy cleanup

                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number,
                  labels: [LABELS.bugReleased],
                });
              } else {
                await safeRemoveLabel(issue_number, LABELS.featureWaiting);
                await safeRemoveLabel(issue_number, LABELS.featurePlanned); // optional cleanup
                await safeRemoveLabel(issue_number, LABELS.legacyFeatureAdded); // legacy cleanup

                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number,
                  labels: [LABELS.featureAddedReleased],
                });
              }

              // 3) Close
              await github.rest.issues.update({ owner, repo, issue_number, state: 'closed' });

              core.info(`#${issue_number}: closed as released (${type}).`);
            }

            // --------------------
            // ISSUE: labeled -> add "waiting for release" comment
            // --------------------
            if (context.eventName === 'issues') {
              const issue = context.payload.issue;
              const appliedLabel = context.payload.label?.name || '';

              // Skip PRs
              if (issue.pull_request) {
                core.info(`PR #${issue.number} â€“ skipping`);
                return;
              }

              if (appliedLabel === LABELS.bugWaiting) {
                await upsertComment(issue.number, MARKERS.bugWaiting, waitingBody('bug'));
                core.info(`#${issue.number}: added/updated waiting-for-release comment (bug).`);
                return;
              }

              if (appliedLabel === LABELS.featureWaiting) {
                await upsertComment(issue.number, MARKERS.featureWaiting, waitingBody('feature'));
                core.info(`#${issue.number}: added/updated waiting-for-release comment (feature).`);
                return;
              }

              core.info(`Label "${appliedLabel}" is not a waiting-for-release label â€“ skipping.`);
              return;
            }

            // --------------------
            // RELEASE: published OR workflow_dispatch -> close all "waiting for release" issues
            // --------------------
            const rel = await getReleaseInfo();
            if (!rel) {
              core.warning('No release found (non-draft/non-prerelease).');
              return;
            }

            // Create target labels if they somehow don't exist
            await ensureLabel(LABELS.bugReleased, '0e8a16', 'Bug fixed and released');
            await ensureLabel(LABELS.featureAddedReleased, '1d76db', 'Feature released');

            const bugIssues = await issuesWithLabelOpen(LABELS.bugWaiting);
            const featureIssues = await issuesWithLabelOpen(LABELS.featureWaiting);

            for (const issue of bugIssues) {
              await closeAsReleased(issue, 'bug', rel.version, rel.url);
            }

            for (const issue of featureIssues) {
              await closeAsReleased(issue, 'feature', rel.version, rel.url);
            }

            core.info(`Done. Processed bugs=${bugIssues.length}, features=${featureIssues.length}.`);
