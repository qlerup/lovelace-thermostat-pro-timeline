name: Reopen issue on "reopen" comment + reset labels when reopened

on:
  issue_comment:
    types: [created, edited]
  issues:
    types: [reopened]

permissions:
  issues: write

jobs:
  reopen_and_labels:
    runs-on: ubuntu-latest
    steps:
      - name: Reopen (on comment) and reset labels (on reopen)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const isPR = (issue) => !!issue?.pull_request;

            // Helper: find actual label name (case-insensitive)
            const findLabel = (labels, target) => {
              const t = target.toLowerCase();
              const found = labels.find(l => (l || "").toLowerCase() === t);
              return found || null;
            };

            const normalizeLabels = (labels = []) =>
              labels
                .map(l => (typeof l === "string" ? l : l?.name))
                .filter(Boolean);

            // Apply the label rules described by you
            const fixLabels = async (issue_number) => {
              const { data } = await github.rest.issues.get({ owner, repo, issue_number });

              // Safety: only issues, not PRs
              if (isPR(data)) {
                core.info(`Skipping label changes for #${issue_number} (it's a PR).`);
                return;
              }

              const current = normalizeLabels(data.labels);

              const featureReleased = findLabel(current, "Feature added - released");
              const bugReleased = findLabel(current, "Bug fixed - released");
              const hasNewFeature = !!findLabel(current, "New feature");
              const hasBug = !!findLabel(current, "bug");

              const toRemove = [];
              const toAdd = [];

              if (featureReleased) {
                toRemove.push(featureReleased);
                if (!hasNewFeature) toAdd.push("New feature");
              }

              if (bugReleased) {
                toRemove.push(bugReleased);
                if (!hasBug) toAdd.push("bug");
              }

              for (const name of toRemove) {
                core.info(`Removing label: ${name}`);
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
                } catch (e) {
                  core.warning(`Could not remove label "${name}" (maybe already removed): ${e.message}`);
                }
              }

              if (toAdd.length) {
                core.info(`Adding labels: ${toAdd.join(", ")}`);
                await github.rest.issues.addLabels({ owner, repo, issue_number, labels: toAdd });
              } else {
                core.info("No labels to add.");
              }
            };

            // Reopen on comment containing the word "reopen"
            if (context.eventName === "issue_comment") {
              const body = (context.payload.comment?.body || "").trim();
              if (!/\breopen\b/i.test(body)) {
                core.info('No "reopen" keyword found. Exiting.');
                return;
              }

              const issue = context.payload.issue;
              if (!issue) {
                core.info("No issue payload. Exiting.");
                return;
              }

              if (isPR(issue)) {
                core.info("This workflow is for issues only. Comment was on a PR. Exiting.");
                return;
              }

              if (issue.state !== "closed") {
                core.info("Issue is not closed. Nothing to do.");
                return;
              }

              const issue_number = issue.number;

              core.info(`Reopening issue #${issue_number}...`);
              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                state: "open",
              });

              // After reopen: fix labels
              await fixLabels(issue_number);
              return;
            }

            // Issue was reopened manually (or by any other action): fix labels
            if (context.eventName === "issues") {
              const issue = context.payload.issue;
              if (!issue) {
                core.info("No issue payload. Exiting.");
                return;
              }

              if (isPR(issue)) {
                core.info("Reopened event is for a PR. Exiting.");
                return;
              }

              const issue_number = issue.number;
              core.info(`Fixing labels on reopen for issue #${issue_number}...`);
              await fixLabels(issue_number);
              return;
            }

            core.info(`Unhandled eventName: ${context.eventName}`);
